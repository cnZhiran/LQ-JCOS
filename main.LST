C51 COMPILER V9.00   MAIN                                                                  11/11/2019 09:26:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <intrins.h>
   3          #include <onewire.h>
   4          
   5          #ifndef u8
   6          #define u8 unsigned char
   7          #endif
   8          
   9          #ifndef u16
  10          #define u16 unsigned int
  11          #endif
  12          
  13          #ifndef u32
  14          #define u32 unsigned long
  15          #endif
  16          
  17          sbit Trig = P1^0;
  18          sbit Echo = P1^1;
  19          
  20          u8 code font[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
  21          u8 code y4=0x80,y5=0xa0,y6=0xc0,y7=0xe0;
  22          
  23          bit temp_flag=0,len_flag=0,break_flag=0,echo_flag=0,tx_flag=0;
  24          bit temp_mod=0;len_mod=1;
  25          u8 dis[8]={0},tx_buf[16]="\0",rx_buf[16]="\0";
  26          u8 key_flag=0,tx_pot=0,rx_pot=0;
  27          u16 temp_timing=0,len_timing=250;
  28          u16 count=0,len=20,key_count=0;
  29          int temp=20;
  30          
  31          void mod_init();
  32          void mod_ctrl();
  33          void read_temp();
  34          void read_len();
  35          u8 scankey();
  36          void dis_smg();
  37          
  38          void Sysclk_init(){
  39   1              AUXR |= 0x04;           //定时器2时钟1T模式
  40   1              T2L = 0x20;                     //设置定时初值
  41   1              T2H = 0xD1;                     //设置定时初值
  42   1          IE2 |= 0x04;                //开定时器2中断
  43   1          EA = 1;
  44   1              AUXR |= 0x10;           //定时器2开始计时
  45   1      }
  46          
  47          void PCA_init(){
  48   1              P_SW1 &= 0xcf;          //(P1.2/ECI, P1.1/CCP0, P1.0/CCP1, P3.7/CCP2)
  49   1          CCON = 0;                       //初始化PCA控制寄存器
  50   1                                          //PCA定时器停止
  51   1                                          //清除CF标志
  52   1                                          //清除模块中断标志
  53   1          CL = 0;                         //复位PCA寄存器
  54   1          CH = 0;
  55   1          CCAP0L = 0;
C51 COMPILER V9.00   MAIN                                                                  11/11/2019 09:26:45 PAGE 2   

  56   1          CCAP0H = 0;
  57   1          CMOD = 0x01;                    //设置PCA时钟源为系统时钟/12,且使能PCA计时溢出中断
  58   1          CCAPM0 = 0x10;                                      //PCA模块0为16位捕获模式(下降沿捕获,可测从低电平开始的整个周期)
  59   1              
  60   1          EA = 1;
  61   1      
  62   1      }
  63          
  64          void UartInit(void)             //4800bps@12.000MHz
  65          {
  66   1              SCON = 0x50;            //8位数据,可变波特率
  67   1              AUXR |= 0x40;           //定时器1时钟为Fosc,即1T
  68   1              AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
  69   1              TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
  70   1              TL1 = 0x8F;                     //设定定时初值
  71   1              TH1 = 0xFD;                     //设定定时初值
  72   1              ET1 = 0;                        //禁止定时器1中断
  73   1              TR1 = 1;                        //启动定时器1
  74   1      }
  75          
  76          void delay100us()               //@12.000MHz
  77          {
  78   1              unsigned char i, j;
  79   1      
  80   1              i = 2;
  81   1              j = 39;
  82   1              do
  83   1              {
  84   2                      while (--j);
  85   2              } while (--i);
  86   1      }
  87          
  88          void delay12us()                //@12.000MHz
  89          {
  90   1              unsigned char i;
  91   1      
  92   1              _nop_();
  93   1              _nop_();
  94   1              i = 33;
  95   1              while (--i);
  96   1      }
  97          
  98          void init(){
  99   1              mod_init();
 100   1              Trig = 0;
 101   1              Echo = 1;
 102   1              PCA_init();
 103   1              Sysclk_init();
 104   1      }
 105          
 106          void loop(){
 107   1              mod_ctrl();
 108   1              dis_smg();
 109   1      }
 110          
 111          void soft_IT(){
 112   1              
 113   1              if(temp_flag) read_temp();
 114   1              if(len_flag) read_len();
 115   1      }
 116          
 117          void mod_init(){
C51 COMPILER V9.00   MAIN                                                                  11/11/2019 09:26:45 PAGE 3   

 118   1              if(temp_mod){
 119   2                      dis[0]=0xc6;
 120   2                      dis[1]=0xff;
 121   2                      dis[2]=0xff;
 122   2                      dis[3]=0xff;
 123   2                      return;
 124   2              }
 125   1              if(len_mod){
 126   2                      dis[0]=0xc7;
 127   2                      dis[1]=0xff;
 128   2                      dis[2]=0xff;
 129   2                      return;
 130   2              }
 131   1      }
 132          
 133          void mod_ctrl(){
 134   1              u8 key;
 135   1      
 136   1              key=scankey();
 137   1              if(temp_mod){
 138   2                      if(key==12){
 139   3                              temp_mod=0;
 140   3                              len_mod=1;
 141   3                              dis[0]=0xc7;
 142   3                              dis[1]=0xff;
 143   3                              dis[2]=0xff;
 144   3                              if(count==0){
 145   4                                      dis[3]=font[9];
 146   4                                      dis[4]=font[9];
 147   4                                      dis[5]=font[9];
 148   4                                      dis[6]=font[9]&0x7f;
 149   4                                      dis[7]=font[9];
 150   4                              }else{
 151   4                                      len=count*0.17;
 152   4                                      dis[3]=font[len/10000];
 153   4                                      dis[4]=font[len/1000%10];
 154   4                                      dis[5]=font[len/100%10];
 155   4                                      dis[6]=font[len/10%10]&0x7f;
 156   4                                      dis[7]=font[len%10];
 157   4                              }
 158   3                              return;
 159   3                      }
 160   2              }
 161   1              if(len_mod){
 162   2                      if(key==12){       
 163   3                              len_mod=0;
 164   3                              temp_mod=1;
 165   3                              dis[0]=0xc6;
 166   3                              dis[1]=0xff;
 167   3                              dis[2]=0xff;
 168   3                              dis[3]=0xff;
 169   3                              dis[4]=font[temp/1000%10];
 170   3                              dis[5]=font[temp/100%10]&0x7f;
 171   3                              dis[6]=font[temp/10%10];
 172   3                              dis[7]=font[temp%10];
 173   3                              return;
 174   3                      }
 175   2              }
 176   1      }
 177          
 178          void read_temp(){
 179   1              int tp;
C51 COMPILER V9.00   MAIN                                                                  11/11/2019 09:26:45 PAGE 4   

 180   1              u8 tl,th;
 181   1      
 182   1              while(init_ds18b20())loop();
 183   1              Write_DS18B20(0xCC);
 184   1              Write_DS18B20(0x44);
 185   1              while(init_ds18b20())loop();
 186   1              Write_DS18B20(0xCC);
 187   1              Write_DS18B20(0xBE);
 188   1              tl=Read_DS18B20();
 189   1              th=Read_DS18B20();
 190   1              tp=(th<<8)|tl;
 191   1              temp=tp*6.25;
 192   1      
 193   1              if(temp_mod){
 194   2                      dis[4]=font[temp/1000%10];
 195   2                      dis[5]=font[temp/100%10]&0x7f;
 196   2                      dis[6]=font[temp/10%10];
 197   2                      dis[7]=font[temp%10];
 198   2              }
 199   1              temp_flag=0;
 200   1      }
 201          void read_len(){
 202   1              u8 i=8;
 203   1                                
 204   1              //发送
 205   1              while(i--){
 206   2                      Trig = 1;
 207   2                      delay12us();
 208   2                      Trig = 0;
 209   2                      delay12us();
 210   2              }
 211   1              //接收
 212   1          CR = 1;                         //PCA定时器开始工作
 213   1          CCF0 = 0;
 214   1              CCAPM0 |= 0x01;                                 //开启中断
 215   1              while(echo_flag!=0&&break_flag!=0)loop();
 216   1              if(len_mod){
 217   2                      if(break_flag){
 218   3                              dis[3]=font[9];
 219   3                              dis[4]=font[9];
 220   3                              dis[5]=font[9];
 221   3                              dis[6]=font[9]&0x7f;
 222   3                              dis[7]=font[9];
 223   3                      }else{
 224   3                              len=count*0.17;
 225   3                              dis[3]=font[len/10000];
 226   3                              dis[4]=font[len/1000%10];
 227   3                              dis[5]=font[len/100%10];
 228   3                              dis[6]=font[len/10%10]&0x7f;
 229   3                              dis[7]=font[len%10];
 230   3                      }
 231   2              }
 232   1              break_flag = 0;
 233   1              echo_flag = 0;
 234   1              len_flag = 0;
 235   1      }
 236          
 237          u8 scankey(){
 238   1              u8 key;
 239   1      
 240   1              P3=0xff;P3&=0xf3;
 241   1              if(P34==0|P35==0){
C51 COMPILER V9.00   MAIN                                                                  11/11/2019 09:26:45 PAGE 5   

 242   2                      delay100us();
 243   2                      if(P34==0|P35==0){
 244   3                              key = P3 &0x30;
 245   3                              if(key_count==0){
 246   4                                      key_count = 1;
 247   4                                      P3=0xff;P3&=0xcf;
 248   4                                      delay12us();
 249   4                                      key |= P3 &0x0c;
 250   4                                      switch(key){
 251   5                                              case 0x14:key_flag=12;return 0;
 252   5                                              case 0x18:key_flag=13;return 0;
 253   5                                              case 0x24:key_flag=16;return 0;
 254   5                                              case 0x28:key_flag=17;return 0;
 255   5                                      }
 256   4                              }
 257   3                              return 0;
 258   3                      }       
 259   2              }
 260   1              if(key_count){
 261   2                      if(key_count<1000){
 262   3                              key_count=0;
 263   3                              return key_flag;
 264   3                      }else{
 265   3                              key_count=0;
 266   3                              return key_flag+10;
 267   3                      }
 268   2              }
 269   1              return 0;
 270   1      }
 271          
 272          void dis_smg(){
 273   1              u8 i;
 274   1      
 275   1              for(i=0;i<8;i++){
 276   2                      P2&=0x1f;
 277   2                      P0=1<<i;
 278   2                      P2|=y6;
 279   2                      _nop_();
 280   2                      P2&=0x1f;
 281   2                      P0=dis[i];
 282   2                      P2|=y7;
 283   2                      delay100us();
 284   2                      P0=0xff;
 285   2              }
 286   1      }
 287          
 288          void main(){
 289   1              init();
 290   1              while(1){
 291   2                      loop();
 292   2                      soft_IT();
 293   2              }       
 294   1      }
 295          
 296          void Uart() interrupt 4 using 2
 297          {
 298   1          if (RI)
 299   1          {
 300   2              RI = 0;                 //清除RI位
 301   2              rx_buf[rx_pot] = SBUF;//存串口数据
 302   2                      if(rx_buf[rx_pot]=='\n'){
 303   3                              rx_pot=0;
C51 COMPILER V9.00   MAIN                                                                  11/11/2019 09:26:45 PAGE 6   

 304   3                      }else{
 305   3                              rx_pot++;
 306   3                      }
 307   2          }
 308   1          if (TI)
 309   1          {
 310   2              TI = 0;                 //清除TI位
 311   2              if(tx_buf[tx_pot]){
 312   3                      SBUF = tx_buf[tx_pot++];                 //写数据到UART数据寄存器
 313   3                      }else{
 314   3                              tx_flag = 0;
 315   3                      }
 316   2          }
 317   1      }
 318          
 319          void PCA_isr() interrupt 7 using 3
 320          {       
 321   1          if (CF)
 322   1          {
 323   2              CF = 0;
 324   2              break_flag=1;
 325   2          }
 326   1          if (CCF0)
 327   1          {
 328   2              CCF0 = 0;
 329   2                              echo_flag = 1;
 330   2                      count=(CCAP0H<<8)|CCAP0L;       //保存本次的捕获值
 331   2                              CCAPM0 &= 0xfe;                         //关闭中断
 332   2                      CR = 0;                                         //PCA定时器停止工作
 333   2                      CL = 0;                     //复位PCA寄存器
 334   2                      CH = 0;
 335   2                      CCAP0L = 0;
 336   2                      CCAP0H = 0;
 337   2                      
 338   2          }
 339   1      }
 340          
 341          void Sysclk_IT() interrupt 12 using 3
 342          {
 343   1              //18B20定时读取
 344   1              if(temp_timing){
 345   2                      temp_timing--;
 346   2              }else{
 347   2                      temp_timing=500;
 348   2                      temp_flag=1;
 349   2              }
 350   1              //超声波定时读取
 351   1              if(len_timing){
 352   2                      len_timing--;
 353   2              }else{
 354   2                      len_timing=1000;
 355   2                      len_flag=1;
 356   2              }
 357   1              //按键时长计数
 358   1              if(key_count){
 359   2                      if(++key_count==0)key_count=1000;
 360   2              }
 361   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1402    ----
C51 COMPILER V9.00   MAIN                                                                  11/11/2019 09:26:45 PAGE 7   

   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     57       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
