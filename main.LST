C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <intrins.h>
   3          #include <string.h>
   4          #include <stdio.h>
   5          #include <onewire.h>
   6          #include <iic.h>
   7          
   8          #ifndef u8
   9          #define u8 unsigned char
  10          #endif
  11          
  12          #ifndef u16
  13          #define u16 unsigned int
  14          #endif
  15          
  16          #ifndef u32
  17          #define u32 unsigned long
  18          #endif
  19          
  20          sbit Trig = P1^0;
  21          sbit Echo = P1^1;
  22          
  23          u8 code font[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
  24          u8 code y4=0x80,y5=0xa0,y6=0xc0,y7=0xe0;
  25          
  26          bit temp_flag=0,len_flag=0,break_flag=0,echo_flag=0,tx_flag=0,rx_flag=0;
  27          bit temp_mod=0;len_mod=1;
  28          u8 dis[8]={0},tx_buf[16]="\0",rx_buf[16]="\0";
  29          u8 key_flag=0,key_sign=0,tx_pot=0,rx_pot=0;
  30          u16 temp_timing=0,len_timing=250;
  31          u16 count=0,len=20,key_count=0;
  32          int temp=20;
  33          
  34          void mod_init();
  35          void mod_ctrl();
  36          void read_temp();
  37          void read_len();
  38          u8 scankey();
  39          void send_str();
  40          void uart_reply();
  41          void dis_smg();
  42          
  43          /*************************************************
  44          *函数：mod_init()系统模式初始化函数
  45          *功能：系统模式初始化
  46          *************************************************/
  47          void mod_init(){
  48   1              if(temp_mod){
  49   2                      dis[0]=0xc6;
  50   2                      dis[1]=0xff;
  51   2                      dis[2]=0xff;
  52   2                      dis[3]=0xff;
  53   2                      return;
  54   2              }
  55   1              if(len_mod){
C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 2   

  56   2                      dis[0]=0xc7;
  57   2                      dis[1]=0xff;
  58   2                      dis[2]=0xff;
  59   2                      return;
  60   2              }
  61   1      }
  62          /*************************************************
  63          *函数：Sysclk_init()系统计时初始化函数
  64          *功能：系统计时初始化
  65          *硬件：使用T2定时器，规定1ms溢出中断一次
  66          *************************************************/
  67          void Sysclk_init(){
  68   1              AUXR |= 0x04;           //定时器2时钟1T模式
  69   1              T2L = 0x20;                     //设置定时初值
  70   1              T2H = 0xD1;                     //设置定时初值
  71   1          IE2 |= 0x04;                //开定时器2中断
  72   1          EA = 1;
  73   1              AUXR |= 0x10;           //定时器2开始计时
  74   1      }
  75          /*************************************************
  76          *函数：PCA_init()PCA定时器初始化函数
  77          *功能：PCA定时器初始化                   
  78          *硬件：使用PCA定时器，规定溢出和P11下降沿中断
  79          *************************************************/
  80          void PCA_init(){
  81   1              P_SW1 &= 0xcf;          //(P1.2/ECI, P1.1/CCP0, P1.0/CCP1, P3.7/CCP2)
  82   1          CCON = 0;                       //初始化PCA控制寄存器
  83   1                                          //PCA定时器停止
  84   1                                          //清除CF标志
  85   1                                          //清除模块中断标志
  86   1          CL = 0;                         //复位PCA寄存器
  87   1          CH = 0;
  88   1          CCAP0L = 0;
  89   1          CCAP0H = 0;
  90   1          CMOD = 0x01;                    //设置PCA时钟源为系统时钟/12,且使能PCA计时溢出中断
  91   1          CCAPM0 = 0x10;                                      //PCA模块0为16位捕获模式(下降沿捕获,可测从低电平开始的整个周期)
  92   1              
  93   1          EA = 1;
  94   1      
  95   1      }
  96          /*************************************************
  97          *函数：Uart_init()串口初始化函数
  98          *功能：串口初始化 
  99          *硬件：使用T1定时器，波特率为4800
 100          *************************************************/
 101          void Uart_init(void)            //4800bps@12.000MHz
 102          {
 103   1              SCON = 0x50;            //8位数据,可变波特率
 104   1              AUXR |= 0x40;           //定时器1时钟为Fosc,即1T
 105   1              AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
 106   1              TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
 107   1              TL1 = 0x8F;                     //设定定时初值
 108   1              TH1 = 0xFD;                     //设定定时初值
 109   1              ET1 = 0;                        //禁止定时器1中断
 110   1              ES = 1;
 111   1              EA = 1;
 112   1              TR1 = 1;                        //启动定时器1
 113   1      }
 114          /*************************************************
 115          *函数：delay_us()微秒级延时函数
 116          *功能：微秒级延时服务
 117          *备注：尽可能的使用STC-ISP的延时计算器，提高延时精度
C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 3   

 118          *************************************************/
 119          void delay100us()               //@12.000MHz
 120          {
 121   1              unsigned char i, j;
 122   1      
 123   1              i = 2;
 124   1              j = 39;
 125   1              do
 126   1              {
 127   2                      while (--j);
 128   2              } while (--i);
 129   1      }
 130          void delay12us()                //@12.000MHz
 131          {
 132   1              unsigned char i;
 133   1      
 134   1              _nop_();
 135   1              _nop_();
 136   1              i = 33;
 137   1              while (--i);
 138   1      }
 139          /*************************************************
 140          *函数：init()初始化函数
 141          *功能：系统进入的初始化服务
 142          *************************************************/
 143          void init(){
 144   1              mod_init();
 145   1              Trig = 0;
 146   1              Echo = 1;
 147   1              PCA_init();
 148   1              Sysclk_init();
 149   1              Uart_init();
 150   1      }
 151          /*************************************************
 152          *函数：loop()快速响应函数
 153          *功能：快速I/O设备的驱动服务，模式变换服务
 154          *备注：要求函数进行一次的时长要尽可能的短，这样不会影响其他函数的延时等待函数。
 155          *************************************************/
 156          void loop(){
 157   1              key_sign=scankey();
 158   1              mod_ctrl();
 159   1              dis_smg();
 160   1      }
 161          /*************************************************
 162          *函数：soft_IT()中断捕获和处理函数
 163          *功能：中断捕获和处理服务
 164          *************************************************/
 165          void soft_IT(){
 166   1              
 167   1              if(temp_flag) read_temp();
 168   1              if(len_flag) read_len();
 169   1              if(rx_flag) uart_reply();
 170   1      }
 171          /*************************************************
 172          *函数：mod_ctrl()模式变换函数
 173          *功能：模式变换服务
 174          *************************************************/
 175          void mod_ctrl(){
 176   1              if(temp_mod){
 177   2                      if(key_sign==12){
 178   3                              temp_mod=0;
 179   3                              len_mod=1;
C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 4   

 180   3                              dis[0]=0xc7;
 181   3                              dis[1]=0xff;
 182   3                              dis[2]=0xff;
 183   3                              if(count==0){
 184   4                                      dis[3]=font[9];
 185   4                                      dis[4]=font[9];
 186   4                                      dis[5]=font[9];
 187   4                                      dis[6]=font[9]&0x7f;
 188   4                                      dis[7]=font[9];
 189   4                              }else{
 190   4                                      len=count*0.17;
 191   4                                      dis[3]=font[len/10000];
 192   4                                      dis[4]=font[len/1000%10];
 193   4                                      dis[5]=font[len/100%10];
 194   4                                      dis[6]=font[len/10%10]&0x7f;
 195   4                                      dis[7]=font[len%10];
 196   4                              }
 197   3                              return;
 198   3                      }
 199   2              }
 200   1              if(len_mod){
 201   2                      if(key_sign==12){          
 202   3                              len_mod=0;
 203   3                              temp_mod=1;
 204   3                              dis[0]=0xc6;
 205   3                              dis[1]=0xff;
 206   3                              dis[2]=0xff;
 207   3                              dis[3]=0xff;
 208   3                              dis[4]=font[temp/1000%10];
 209   3                              dis[5]=font[temp/100%10]&0x7f;
 210   3                              dis[6]=font[temp/10%10];
 211   3                              dis[7]=font[temp%10];
 212   3                              return;
 213   3                      }
 214   2              }
 215   1      }
 216          /*************************************************
 217          *函数：read_temp()读温度函数
 218          *功能：读取温度
 219          *************************************************/
 220          void read_temp(){
 221   1              int tp;
 222   1              u8 tl,th;
 223   1      
 224   1              while(init_ds18b20())loop();
 225   1              Write_DS18B20(0xCC);
 226   1              Write_DS18B20(0x44);
 227   1              while(init_ds18b20())loop();
 228   1              Write_DS18B20(0xCC);
 229   1              Write_DS18B20(0xBE);
 230   1              tl=Read_DS18B20();
 231   1              th=Read_DS18B20();
 232   1              tp=(th<<8)|tl;
 233   1              temp=tp*6.25;
 234   1      
 235   1              if(temp_mod){
 236   2                      dis[4]=font[temp/1000%10];
 237   2                      dis[5]=font[temp/100%10]&0x7f;
 238   2                      dis[6]=font[temp/10%10];
 239   2                      dis[7]=font[temp%10];
 240   2              }
 241   1              temp_flag=0;
C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 5   

 242   1      
 243   1      }       
 244          /*************************************************
 245          *函数：read_len()读距离函数
 246          *功能：读取距离
 247          *************************************************/
 248          void read_len(){
 249   1              u8 i=8;
 250   1                                
 251   1              //发送
 252   1              while(i--){
 253   2                      Trig = 1;
 254   2                      delay12us();
 255   2                      Trig = 0;
 256   2                      delay12us();
 257   2              }
 258   1              //接收
 259   1          CR = 1;                         //PCA定时器开始工作
 260   1          CCF0 = 0;
 261   1              CCAPM0 |= 0x01;                                 //开启中断
 262   1              while(echo_flag!=0&&break_flag!=0)loop();
 263   1              if(len_mod){
 264   2                      if(break_flag){
 265   3                              dis[3]=font[9];
 266   3                              dis[4]=font[9];
 267   3                              dis[5]=font[9];
 268   3                              dis[6]=font[9]&0x7f;
 269   3                              dis[7]=font[9];
 270   3                      }else{
 271   3                              len=count*0.17;
 272   3                              dis[3]=font[len/10000];
 273   3                              dis[4]=font[len/1000%10];
 274   3                              dis[5]=font[len/100%10];
 275   3                              dis[6]=font[len/10%10]&0x7f;
 276   3                              dis[7]=font[len%10];
 277   3                      }
 278   2              }
 279   1              break_flag = 0;
 280   1              echo_flag = 0;
 281   1              len_flag = 0;
 282   1      } 
 283          /*************************************************
 284          *函数：send_str()发送字符串函数
 285          *功能：向串口发送字符串
 286          *************************************************/
 287          void send_str(){
 288   1              tx_flag = 1;
 289   1              tx_pot = 0;
 290   1          SBUF = tx_buf[tx_pot++];            //写数据到UART数据寄存器
 291   1      } 
 292          /*************************************************
 293          *函数：uart_reply()串口响应函数
 294          *功能：串口响应接收字符串
 295          *************************************************/
 296          void uart_reply(){
 297   1                      rx_flag = 0;
 298   1                      if(strcmp(rx_buf,"temp\r\n")==0){
 299   2                              while(tx_flag) loop();
 300   2                              sprintf(tx_buf,"temp:%.2f\r\n",temp/100.0);
 301   2                              send_str();
 302   2                      }else if(strcmp(rx_buf,"len\r\n")==0){
 303   2                              while(tx_flag) loop();
C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 6   

 304   2                              sprintf(tx_buf,"len:%.1f\r\n",len/10.0);
 305   2                              send_str();
 306   2                      }
 307   1      }
 308          /*************************************************
 309          *函数：scankey()扫描按键函数
 310          *功能：扫描按键
 311          *************************************************/
 312          u8 scankey(){
 313   1              u8 key;
 314   1      
 315   1              P3=0xff;P3&=0xf3;
 316   1              if(P34==0|P35==0){
 317   2                      delay100us();
 318   2                      if(P34==0|P35==0){
 319   3                              key = P3 &0x30;
 320   3                              if(key_count==0){
 321   4                                      key_count = 1;
 322   4                                      P3=0xff;P3&=0xcf;
 323   4                                      delay12us();
 324   4                                      key |= P3 &0x0c;
 325   4                                      switch(key){
 326   5                                              case 0x14:key_flag=12;return 0;
 327   5                                              case 0x18:key_flag=13;return 0;
 328   5                                              case 0x24:key_flag=16;return 0;
 329   5                                              case 0x28:key_flag=17;return 0;
 330   5                                      }
 331   4                              }
 332   3                              return 0;
 333   3                      }       
 334   2              }
 335   1              if(key_count){
 336   2                      if(key_count<1000){
 337   3                              key_count=0;
 338   3                              return key_flag;
 339   3                      }else{
 340   3                              key_count=0;
 341   3                              return key_flag+10;
 342   3                      }
 343   2              }
 344   1              return 0;
 345   1      }
 346          /*************************************************
 347          *函数：dis_smg()数码管显示函数
 348          *功能：驱动显示数码管
 349          *************************************************/
 350          void dis_smg(){
 351   1              u8 i;
 352   1      
 353   1              for(i=0;i<8;i++){
 354   2                      P2&=0x1f;
 355   2                      P0=1<<i;
 356   2                      P2|=y6;
 357   2                      _nop_();
 358   2                      P2&=0x1f;
 359   2                      P0=dis[i];
 360   2                      P2|=y7;
 361   2                      delay100us();
 362   2                      P0=0xff;
 363   2              }
 364   1      }
 365          /*************************************************
C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 7   

 366          *函数：main()系统进入函数
 367          *功能：系统进入初始化服务，系统进行服务
 368          *************************************************/
 369          void main(){
 370   1              //初始化
 371   1              init();
 372   1              while(1){
 373   2                      //快速I/O操作
 374   2                      loop();
 375   2                      //中断检查与处理
 376   2                      soft_IT();
 377   2              }       
 378   1      }
 379          /*************************************************
 380          *函数：Uart()串口中断处理函数
 381          *功能：软件中断标志的定时置位服务，毫秒级的计时计数服务
 382          *硬件：使用T2定时器，规定1ms溢出中断一次
 383          *************************************************/
 384          void Uart() interrupt 4 using 2
 385          {
 386   1          if (RI){
 387   2              RI = 0;                 //清除RI位
 388   2              rx_buf[rx_pot] = SBUF;//存串口数据
 389   2                      if(rx_buf[rx_pot]=='?'){
 390   3                              rx_pot = 0;
 391   3                      }else if(rx_buf[rx_pot]=='\n'){
 392   3                              rx_buf[++rx_pot] ='\0';
 393   3                              rx_flag = 1;
 394   3      //                      rx_pot++;
 395   3                                              
 396   3      //                      //请尽量在此处添加接收串口字符串的函数
 397   3      //                      if(strcmp(rx_buf,"temp\r\n")==0){ 
 398   3      //                              while(tx_flag) loop();
 399   3      //                              sprintf(tx_buf,"temp:%.2f\n",temp/100.0);
 400   3      //                              send_str();
 401   3      //                      }
 402   3                              rx_pot = 0; 
 403   3                              
 404   3                      }else{
 405   3                              if(++rx_pot>=15) rx_pot = 0;
 406   3                      }
 407   2          }
 408   1          if (TI){
 409   2              TI = 0;                 //清除TI位
 410   2              if(tx_buf[tx_pot]){
 411   3                      SBUF = tx_buf[tx_pot];                 //写数据到UART数据寄存器
 412   3                              if(++tx_pot>=15) tx_pot=0;
 413   3                      }else{
 414   3                              tx_pot = 0;
 415   3                              tx_flag = 0;
 416   3                      }
 417   2          }
 418   1      }
 419          /*************************************************
 420          *函数：PCA_isr()PCA定时器中断处理函数
 421          *功能：脉冲时长计数服务
 422          *硬件：使用PCA定时器，规定溢出和P11下降沿中断
 423          *输出：count记录从定时器打开到下降沿之前的时长计数
 424          *************************************************/
 425          void PCA_isr() interrupt 7 using 3
 426          {       
 427   1          if (CF)
C51 COMPILER V9.00   MAIN                                                                  11/20/2019 20:06:25 PAGE 8   

 428   1          {
 429   2              CF = 0;                                         //定时器溢出中断
 430   2              break_flag=1;
 431   2          }
 432   1          if (CCF0)
 433   1          {
 434   2                      CCF0 = 0;
 435   2                      echo_flag = 1;
 436   2                      count=(CCAP0H<<8)|CCAP0L;       //保存本次的捕获值
 437   2                      CCAPM0 &= 0xfe;                         //关闭中断
 438   2              CR = 0;                                         //PCA定时器停止工作
 439   2                      CL = 0;                     //复位PCA寄存器
 440   2                      CH = 0;
 441   2                      CCAP0L = 0;
 442   2                      CCAP0H = 0;
 443   2                      
 444   2          }
 445   1      }
 446          /*************************************************
 447          *函数：Sysclk_IT()系统定时中断处理函数
 448          *功能：软件中断标志的定时置位服务，毫秒级的计时计数服务
 449          *硬件：使用T2定时器，规定1ms溢出中断一次
 450          *************************************************/
 451          void Sysclk_IT() interrupt 12 using 3
 452          {
 453   1              //18B20定时读取
 454   1              if(temp_timing){
 455   2                      temp_timing--;
 456   2              }else{
 457   2                      temp_timing=500;
 458   2                      temp_flag=1;
 459   2              }
 460   1              //超声波定时读取
 461   1              if(len_timing){
 462   2                      len_timing--;
 463   2              }else{
 464   2                      len_timing=1000;
 465   2                      len_flag=1;
 466   2              }
 467   1              //按键时长计数
 468   1              if(key_count){
 469   2                      if(++key_count==0)key_count=1000;
 470   2              }
 471   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1592    ----
   CONSTANT SIZE    =     50    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     58       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
