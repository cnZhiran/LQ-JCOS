C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <intrins.h>
   3          #include <string.h>
   4          #include <stdio.h>
   5          #include <onewire.h>
   6          #include <iic.h>
   7          
   8          #ifndef u8
   9          #define u8 unsigned char
  10          #endif
  11          
  12          #ifndef u16
  13          #define u16 unsigned int
  14          #endif
  15          
  16          #ifndef u32
  17          #define u32 unsigned long
  18          #endif
  19          
  20          #define temp_mod 0
  21          #define len_mod 1
  22          #define vol_mod 2
  23          #define bright_mod 3
  24          #define eep_mod 4
  25          #define freq_mod 5
  26          
  27          #define len_read_IT   //len_read_once一次性读距离，len_read_IT发读分离法读距离
  28          
  29          
  30          sbit Trig = P1^0;
  31          sbit Echo = P1^1;
  32          
  33          u8 code font[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
  34          u8 code y4=0x80,y5=0xa0,y6=0xc0,y7=0xe0;
  35          
  36          u8 bdata led=0,out=0;
  37          bit temp_sign=0,len_flag=0,vol_flag=0,bright_flag=0,break_flag=0,echo_flag=0,tx_flag=0,rx_flag=0;
  38          u8 idata dis[8]={0},tx_buf[16]="init_well\r\n",rx_buf[16]="\0",freq_T=0,freq_H=0;
  39          u8 idata key_flag=0,key_sign=0,tx_pot=0,rx_pot=0,cnt=0,write_flag=0,write_sign=0,read_flag=0,read_sign=0;
  40          u16 idata key_count=0,temp_timing=250,vol_timing=125,len_timing=0,bright_timing=375,delay_timing=0,write_t
             -iming=500,freq_timing=312,count_timing=0;
  41          u16 mod_flag=len_mod,read_mod=len_mod,*write_addr,*read_addr,freq_sign=0;
  42          u16 length=0,temp=-2000,len=20,vol=250,bright=250;
  43          u32 freq=1000;
  44          
  45          sbit l1=led^0;
  46          sbit l2=led^1;
  47          sbit l3=led^2;
  48          sbit l4=led^3;
  49          sbit l5=led^4;
  50          sbit l6=led^5;
  51          sbit l7=led^6;
  52          sbit l8=led^7;
  53          sbit relay=out^4;
  54          sbit buzz=out^6;
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 2   

  55          
  56          void mod_init();
  57          void mod_ctrl();
  58          void read_temp();
  59          #ifdef len_read_once
              void read_len();
              #elif defined len_read_IT 
  62          void send_len();
  63          void read_len();
  64          #endif
  65          void read_vol();
  66          void read_bright();
  67          void scankey();
  68          void send_str();
  69          void uart_reply();
  70          void eep_write();
  71          void eep_read();
  72          void freq_read();
  73          
  74          void dis_smg();
  75          void dis_led();
  76          void dis_out();
  77          
  78          /*************************************************
  79          *函数：mod_init()系统模式初始化函数
  80          *功能：系统模式初始化
  81          *************************************************/
  82          void mod_init(){
  83   1        u8 i;
  84   1        
  85   1        switch(mod_flag){
  86   2        case temp_mod:
  87   2          dis[0]=0xc6;
  88   2          dis[1]=0xff;
  89   2          dis[2]=0xff;
  90   2          dis[3]=0xff;
  91   2          if(temp>=0x8000){
  92   3            dis[3]=font[-temp/10000%10];
  93   3            dis[4]=font[-temp/1000%10];
  94   3            dis[5]=font[-temp/100%10]&0x7f;
  95   3            dis[6]=font[-temp/10%10];
  96   3            dis[7]=font[-temp%10];
  97   3            for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
  98   3            dis[i-1]=0xbf;
  99   3          }else{
 100   3            dis[3]=font[temp/10000%10];
 101   3            dis[4]=font[temp/1000%10];
 102   3            dis[5]=font[temp/100%10]&0x7f;
 103   3            dis[6]=font[temp/10%10];
 104   3            dis[7]=font[temp%10];
 105   3            for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 106   3          }
 107   2          if(write_flag == 0&&write_sign == 0) write_addr = &temp;
 108   2          return;
 109   2        case len_mod:
 110   2          dis[0]=0xc7;
 111   2          dis[1]=0xff;
 112   2          dis[2]=0xff;
 113   2          if(length==0){
 114   3            dis[3]=font[9];
 115   3            dis[4]=font[9];
 116   3            dis[5]=font[9];
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 3   

 117   3            dis[6]=font[9]&0x7f;
 118   3            dis[7]=font[9];
 119   3          }else{
 120   3            dis[3]=font[len/10000];
 121   3            dis[4]=font[len/1000%10];
 122   3            dis[5]=font[len/100%10];
 123   3            dis[6]=font[len/10%10]&0x7f;
 124   3            dis[7]=font[len%10];
 125   3            for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 126   3          }
 127   2          if(write_flag == 0&&write_sign == 0) write_addr = &len;
 128   2          return;
 129   2        case vol_mod:
 130   2          dis[0]=0xc1;
 131   2          dis[1]=0xff;
 132   2          dis[2]=0xff;
 133   2          dis[3]=0xff;
 134   2          dis[4]=0xff;
 135   2          dis[5]=font[vol/100%10]&0x7f;
 136   2          dis[6]=font[vol/10%10];
 137   2          dis[7]=font[vol%10];
 138   2          if(write_flag == 0&&write_sign == 0) write_addr = &vol;
 139   2          return;
 140   2        case bright_mod:
 141   2          dis[0]=0x83;
 142   2          dis[1]=0xff;
 143   2          dis[2]=0xff;
 144   2          dis[3]=0xff;
 145   2          dis[4]=0xff;
 146   2          dis[5]=font[bright/100%10]&0x7f;
 147   2          dis[6]=font[bright/10%10];
 148   2          dis[7]=font[bright%10];
 149   2          if(write_flag == 0&&write_sign == 0) write_addr = &bright;
 150   2          return;
 151   2        case freq_mod:
 152   2          dis[0]=0x8e;
 153   2          dis[1]=font[freq/1000000%10];
 154   2          dis[2]=font[freq/100000%10];
 155   2          dis[3]=font[freq/10000%10];
 156   2          dis[4]=font[freq/1000%10];
 157   2          dis[5]=font[freq/100%10];
 158   2          dis[6]=font[freq/10%10];
 159   2          dis[7]=font[freq%10];
 160   2          for(i=1;dis[i]==font[0]&&i<8;i++) dis[i]=0xff;
 161   2          if(write_flag == 0&&write_sign == 0) write_addr = (u16 *)&freq;
 162   2          return;
 163   2        }
 164   1      }
 165          /*************************************************
 166          *函数：Sysclk_init()系统计时初始化函数
 167          *功能：系统计时初始化
 168          *硬件：使用T2定时器，规定1ms溢出中断一次
 169          *************************************************/
 170          void Sysclk_init(){
 171   1        AUXR |= 0x04;   //定时器2时钟1T模式
 172   1        T2L = 0x20;     //设置定时初值
 173   1        T2H = 0xD1;     //设置定时初值
 174   1        IE2 |= 0x04;    //开定时器2中断
 175   1        EA = 1;
 176   1        AUXR |= 0x10;   //定时器2开始计时
 177   1      }
 178          /*************************************************
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 4   

 179          *函数：PCA_init()PCA定时器初始化函数
 180          *功能：PCA定时器初始化       
 181          *硬件：使用PCA定时器，规定溢出和P11下降沿中断
 182          *************************************************/
 183          void PCA_init(){
 184   1        P_SW1 &= 0xcf;    //(P1.2/ECI, P1.1/CCP0, P1.0/CCP1, P3.7/CCP2)
 185   1        CCON = 0;                       //初始化PCA控制寄存器
 186   1                                        //PCA定时器停止
 187   1                                        //清除CF标志
 188   1                                        //清除模块中断标志
 189   1        CL = 0;                         //复位PCA寄存器
 190   1        CH = 0;
 191   1        CMOD = 0x01;                    //设置PCA时钟源,允许溢出中断
 192   1        CCAPM0 = 0x11;                  //PCA模块0为下降沿触发,开启中断。
 193   1        EA = 1;
 194   1      }
 195          /*************************************************
 196          *函数：Uart_init()串口初始化函数
 197          *功能：串口初始化 
 198          *硬件：使用T1定时器，波特率为4800
 199          *************************************************/
 200          void Uart_init(void)    //4800bps@12.000MHz
 201          {
 202   1        SCON = 0x50;    //8位数据,可变波特率
 203   1        AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
 204   1        AUXR &= 0xFE;   //串口1选择定时器1为波特率发生器
 205   1        TMOD &= 0x0F;   //设定定时器1为16位自动重装方式
 206   1        TL1 = 0x8F;     //设定定时初值
 207   1        TH1 = 0xFD;     //设定定时初值
 208   1        ET1 = 0;      //禁止定时器1中断
 209   1        ES = 1;
 210   1        EA = 1;
 211   1        TR1 = 1;      //启动定时器1
 212   1      
 213   1        send_str();
 214   1      }
 215          /*************************************************
 216          *函数：delay_us()微秒级延时函数
 217          *功能：微秒级延时服务
 218          *备注：尽可能的使用STC-ISP的延时计算器，提高延时精度
 219          *************************************************/
 220          void T0init(void)   //100微秒@12.000MHz
 221          {
 222   1        AUXR &= 0x7F;   //定时器时钟12T模式
 223   1        TMOD |= 0x07;   //设置定时器模式
 224   1        TL0 = 0x00;   //设置定时初值
 225   1        TH0 = 0x00;   //设置定时初值
 226   1        TF0 = 0;    //清除TF0标志
 227   1        ET0 = 1;
 228   1        EA = 1;
 229   1        TR0 = 1;    //定时器0开始计时
 230   1      }
 231          /*************************************************
 232          *函数：delay_us()微秒级延时函数
 233          *功能：微秒级延时服务
 234          *备注：尽可能的使用STC-ISP的延时计算器，提高延时精度
 235          *************************************************/
 236          void delay100us()   //@12.000MHz
 237          {
 238   1        unsigned char i, j;
 239   1      
 240   1        i = 2;
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 5   

 241   1        j = 39;
 242   1        do
 243   1        {
 244   2          while (--j);
 245   2        } while (--i);
 246   1      }
 247          void delay12us()    //@12.000MHz
 248          {
 249   1        unsigned char i;
 250   1      
 251   1        _nop_();
 252   1        _nop_();
 253   1        i = 33;
 254   1        while (--i);
 255   1      }
 256          /*************************************************
 257          *函数：init()初始化函数
 258          *功能：系统进入的初始化服务
 259          *************************************************/
 260          void init(){
 261   1        mod_init();
 262   1        Trig = 0;
 263   1        Echo = 1;
 264   1        PCA_init();
 265   1        Sysclk_init();
 266   1        T0init();
 267   1        Uart_init();
 268   1      }
 269          /*************************************************
 270          *函数：loop()快速响应函数
 271          *功能：快速I/O设备的驱动服务，模式变换服务
 272          *备注：要求函数进行一次的时长要尽可能的短，这样不会影响其他函数的延时等待函数。
 273          *************************************************/
 274          void loop(){
 275   1        scankey();
 276   1        mod_ctrl();
 277   1        dis_smg();
 278   1        dis_led();
 279   1        dis_out();
 280   1      }
 281          /*************************************************
 282          *函数：soft_IT()中断捕获和处理函数
 283          *功能：中断捕获和处理服务
 284          *************************************************/
 285          void soft_IT(){
 286   1        
 287   1        if(temp_sign) read_temp();
 288   1        if(vol_flag) read_vol();
 289   1        if(bright_flag) read_bright();
 290   1        #ifdef len_read_once
                if(len_flag) read_len();
                #elif defined len_read_IT
 293   1        if(len_flag) send_len();
 294   1        if(echo_flag||break_flag) read_len();
 295   1        #endif
 296   1        if(write_sign) eep_write();
 297   1        if(read_sign) eep_read();
 298   1        if(freq_sign) freq_read();
 299   1        if(rx_flag) uart_reply();
 300   1      }
 301          /*************************************************
 302          *函数：mod_ctrl()模式变换函数
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 6   

 303          *功能：模式变换服务
 304          *************************************************/
 305          void mod_ctrl(){
 306   1        if(read_flag == 0){
 307   2          if(key_sign==4){
 308   3            mod_flag=len_mod;
 309   3            mod_init();
 310   3          }else if(key_sign==5){
 311   3            mod_flag=temp_mod;
 312   3            mod_init();
 313   3          }else if(key_sign==8){
 314   3            mod_flag=vol_mod;
 315   3            mod_init();
 316   3          }else if(key_sign==9){
 317   3            mod_flag=bright_mod;
 318   3            mod_init();
 319   3          }else if(key_sign==13){
 320   3            read_addr = write_addr;
 321   3            read_mod = mod_flag;
 322   3            write_flag = 10;
 323   3            l6 = 1;
 324   3            mod_init();
 325   3          }else if(key_sign==12){
 326   3            mod_flag=freq_mod;
 327   3            mod_init();
 328   3          }else if(key_sign==23){
 329   3            if(write_flag == 0 && write_sign == 0){
 330   4              mod_flag = read_mod;
 331   4              mod_init();
 332   4              mod_flag = eep_mod;
 333   4              l7 = 1;
 334   4              read_flag = 9;
 335   4              read_sign = 10;
 336   4            }
 337   3          }
 338   2        }else{
 339   2          if(key_sign==13){
 340   3            read_sign = read_flag--;
 341   3            if(read_flag == 0) read_flag = 10;
 342   3            mod_init();
 343   3          }else if(key_sign==23){
 344   3            l7 = 0;
 345   3            mod_flag = read_mod;
 346   3            read_flag = 0;
 347   3            mod_init();
 348   3          }
 349   2        }
 350   1        key_sign = 0;
 351   1      }
 352          /*************************************************
 353          *函数：read_temp()读温度函数
 354          *功能：读取温度
 355          *************************************************/
 356          void read_temp(){
 357   1        int tp;
 358   1        u8 tl,th,i;
 359   1      
 360   1        l1=1;
 361   1        while(init_ds18b20())loop();
 362   1        Write_DS18B20(0xCC);
 363   1        Write_DS18B20(0x44);
 364   1        while(init_ds18b20())loop();
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 7   

 365   1        Write_DS18B20(0xCC);
 366   1        Write_DS18B20(0xBE);
 367   1        tl=Read_DS18B20();
 368   1        th=Read_DS18B20();
 369   1        tp=(th<<8)|tl;
 370   1        temp=tp*6.25;
 371   1      
 372   1        if(mod_flag == temp_mod){
 373   2          if(temp>=0x8000){
 374   3            dis[3]=font[-temp/10000%10];
 375   3            dis[4]=font[-temp/1000%10];
 376   3            dis[5]=font[-temp/100%10]&0x7f;
 377   3            dis[6]=font[-temp/10%10];
 378   3            dis[7]=font[-temp%10];
 379   3            for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 380   3            dis[i-1]=0xbf;
 381   3          }else{
 382   3            dis[3]=font[temp/10000%10];
 383   3            dis[4]=font[temp/1000%10];
 384   3            dis[5]=font[temp/100%10]&0x7f;
 385   3            dis[6]=font[temp/10%10];
 386   3            dis[7]=font[temp%10];
 387   3            for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 388   3          }
 389   2        }
 390   1        temp_sign = 0;
 391   1        l1=0;
 392   1      } 
 393          /*************************************************
 394          *函数：read_len()一次性读距离函数
 395          *功能：读取距离
 396          *************************************************/
 397          #ifdef len_read_once
              void read_len(){
                u8 i=8;
                
                break_flag = 0;
                echo_flag = 0;
                len_flag = 0;
                //发送
                while(i--){
                  Trig = 1;
                  delay12us();
                  Trig = 0;
                  delay12us();
                }
                CL = 0;
                CH = 0;
                CCF0 = 0;
                CF = 0;
                CR = 1;                 //PCA定时器开始工作
                CCAPM0 |= 0x01;         //开启中断
                while(echo_flag==0&&break_flag==0)loop();
                //接收
                if(break_flag){
                  len=9999;
                  if(mod_flag==len_mod){
                    dis[3]=font[9];
                    dis[4]=font[9];
                    dis[5]=font[9];
                    dis[6]=font[9]&0x7f;
                    dis[7]=font[9];
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 8   

                  }
                }else if(echo_flag){
                  len=length*0.17;
                  if(mod_flag==len_mod){
                    dis[3]=font[len/10000];
                    dis[4]=font[len/1000%10];
                    dis[5]=font[len/100%10];
                    dis[6]=font[len/10%10]&0x7f;
                    dis[7]=font[len%10];
                    for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
                  }
                }
              } 
              /*************************************************
              *函数：send_len()+read_len()发读分离法读距离函数
              *功能：读取距离
              *************************************************/
              #elif defined len_read_IT
 445          //发送
 446          void send_len(){
 447   1        u8 i=8;
 448   1        
 449   1        break_flag = 0;
 450   1        echo_flag = 0;
 451   1        len_flag = 0;
 452   1        while(i--){
 453   2          Trig = 1;
 454   2          delay12us();
 455   2          Trig = 0;
 456   2          delay12us();
 457   2        }
 458   1        CL = 0;                 //计时器清零
 459   1        CH = 0;
 460   1        CCF0 = 0;               //清标志
 461   1        CF = 0;
 462   1        CR = 1;                 //PCA定时器开始工作
 463   1        CCAPM0 |= 0x01;         //开启中断
 464   1      }
 465          
 466          //接收
 467          void read_len(){
 468   1        u8 i;
 469   1        
 470   1        if(echo_flag){
 471   2          len=length*0.17;
 472   2          if(mod_flag==len_mod){
 473   3            dis[3]=font[len/10000];
 474   3            dis[4]=font[len/1000%10];
 475   3            dis[5]=font[len/100%10];
 476   3            dis[6]=font[len/10%10]&0x7f;
 477   3            dis[7]=font[len%10];
 478   3            for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 479   3          }
 480   2        }else if(break_flag){
 481   2          len=9999;
 482   2          if(mod_flag==len_mod){
 483   3            dis[3]=font[9];
 484   3            dis[4]=font[9];
 485   3            dis[5]=font[9];
 486   3            dis[6]=font[9]&0x7f;
 487   3            dis[7]=font[9];
 488   3          }
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 9   

 489   2        }
 490   1      }
 491          #endif
 492          /*************************************************
 493          *函数：read_vol()读电位器函数
 494          *功能：读取电位器电压
 495          *************************************************/
 496          void read_vol(){
 497   1        l3=1;
 498   1        vol_flag = 0;
 499   1        IIC_Start();
 500   1        IIC_SendByte(0x90);
 501   1        IIC_WaitAck();
 502   1        IIC_SendByte(0x03);
 503   1        IIC_WaitAck();
 504   1        IIC_Start();
 505   1        IIC_SendByte(0x91);
 506   1        IIC_WaitAck();
 507   1        IIC_RecByte();
 508   1        IIC_SendAck(0);
 509   1        vol=IIC_RecByte();
 510   1        vol=vol*500.0/255;
 511   1        IIC_Stop();
 512   1      
 513   1        if(mod_flag==vol_mod){
 514   2          dis[5]=font[vol/100%10]&0x7f;
 515   2          dis[6]=font[vol/10%10];
 516   2          dis[7]=font[vol%10];
 517   2        }
 518   1        if(vol>300){
 519   2          buzz=1;
 520   2        }else{
 521   2          buzz=0;
 522   2        }
 523   1        l3=0;
 524   1      }
 525          /*************************************************
 526          *函数：read_bright()读亮度函数
 527          *功能：读取光敏电阻电压
 528          *************************************************/
 529          void read_bright(){
 530   1        l4=1;
 531   1        bright_flag = 0;
 532   1        IIC_Start();
 533   1        IIC_SendByte(0x90);
 534   1        IIC_WaitAck();
 535   1        IIC_SendByte(0x01);
 536   1        IIC_WaitAck();
 537   1        IIC_Start();
 538   1        IIC_SendByte(0x91);
 539   1        IIC_WaitAck();
 540   1        IIC_RecByte();
 541   1        IIC_SendAck(0);
 542   1        bright=IIC_RecByte();
 543   1        bright=bright*500.0/255;
 544   1        IIC_Stop();
 545   1      
 546   1        if(mod_flag==bright_mod){
 547   2          dis[5]=font[bright/100%10]&0x7f;
 548   2          dis[6]=font[bright/10%10];
 549   2          dis[7]=font[bright%10];
 550   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 10  

 551   1        if(bright>300){
 552   2          relay=1;
 553   2        }else{
 554   2          relay=0;
 555   2        }
 556   1        l4=0;
 557   1      } 
 558          /*************************************************
 559          *函数：send_str()发送字符串函数
 560          *功能：向串口发送字符串
 561          *************************************************/
 562          void send_str(){
 563   1        tx_flag = 1;
 564   1        tx_pot = 0;
 565   1        SBUF = tx_buf[tx_pot++];    //写数据到UART数据寄存器
 566   1      }
 567          /*************************************************
 568          *函数：eep_write()EEPROM写函数
 569          *功能：向EEPROM写字节
 570          *************************************************/
 571          void eep_write(){
 572   1        IIC_Start();
 573   1        IIC_SendByte(0xa0);
 574   1        IIC_WaitAck();
 575   1        IIC_SendByte(write_sign-1<<1);
 576   1        IIC_WaitAck();
 577   1        IIC_SendByte(((u8 *)write_addr)[0]);
 578   1        IIC_WaitAck();
 579   1        IIC_SendByte(((u8 *)write_addr)[1]);
 580   1        IIC_WaitAck();
 581   1        IIC_Stop();
 582   1        write_sign = 0;
 583   1        if(write_flag == 0){
 584   2          l6 = 0;
 585   2          if(read_mod != mod_flag)mod_init();
 586   2        }
 587   1      }
 588          /*************************************************
 589          *函数：eep_read()EEPROM读函数
 590          *功能：向EEPROM读字节
 591          *************************************************/
 592          void eep_read(){
 593   1        IIC_Start();
 594   1        IIC_SendByte(0xa0);
 595   1        IIC_WaitAck();
 596   1        IIC_SendByte(read_sign-1<<1);
 597   1        IIC_WaitAck();
 598   1        IIC_Start();
 599   1        IIC_SendByte(0xa1);
 600   1        IIC_WaitAck();
 601   1        ((u8 *)read_addr)[0] = IIC_RecByte();
 602   1        IIC_SendAck(0);
 603   1        ((u8 *)read_addr)[1] = IIC_RecByte();
 604   1        IIC_Stop();
 605   1        mod_flag = read_mod;
 606   1        mod_init();
 607   1        mod_flag = eep_mod;
 608   1        read_sign = 0;
 609   1      }
 610          /*************************************************
 611          *函数：uart_reply()串口响应函数
 612          *功能：串口响应接收字符串
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 11  

 613          *************************************************/
 614          void freq_read(){
 615   1        u8 i;
 616   1        
 617   1        freq = ((u32)freq_sign|(u32)freq_H<<8);
 618   1        if(mod_flag == freq_mod){
 619   2          dis[1]=font[freq/1000000%10];
 620   2          dis[2]=font[freq/100000%10];
 621   2          dis[3]=font[freq/10000%10];
 622   2          dis[4]=font[freq/1000%10];
 623   2          dis[5]=font[freq/100%10];
 624   2          dis[6]=font[freq/10%10];
 625   2          dis[7]=font[freq%10];
 626   2          for(i=1;dis[i]==font[0]&&i<8;i++) dis[i]=0xff;
 627   2        }
 628   1        freq_sign = 0;
 629   1        freq_H = 0;
 630   1      }
 631          /*************************************************
 632          *函数：uart_reply()串口响应函数
 633          *功能：串口响应接收字符串
 634          *************************************************/
 635          void uart_reply(){
 636   1        l5=1;
 637   1        rx_flag = 0;
 638   1        if(strcmp(rx_buf,"temp\r\n")==0){
 639   2          while(tx_flag) loop();
 640   2          sprintf(tx_buf,"temp:%.2f'C\r\n",temp/100.0);
 641   2          send_str();
 642   2        }else if(strcmp(rx_buf,"len\r\n")==0){
 643   2          while(tx_flag) loop();
 644   2          sprintf(tx_buf,"len:%.1fcm\r\n",len/10.0);
 645   2          send_str();
 646   2        }else if(strcmp(rx_buf,"vol\r\n")==0){
 647   2          while(tx_flag) loop();
 648   2          sprintf(tx_buf,"vol:%.2fV\r\n",vol/100.0);
 649   2          send_str();
 650   2        }else if(strcmp(rx_buf,"bright\r\n")==0){
 651   2          while(tx_flag) loop();
 652   2          sprintf(tx_buf,"bright:%.2fV\r\n",bright/100.0);
 653   2          send_str();
 654   2        }
 655   1        l5=0;
 656   1      }
 657          /*************************************************
 658          *函数：scankey()扫描按键函数
 659          *功能：扫描按键
 660          *************************************************/
 661          void scankey(){
 662   1        u8 key;
 663   1      
 664   1        P4=0xff;P3=0xff;P3&=0xf3;
 665   1        if(P35==0|P42==0|P44==0){
 666   2          if(key_count==0){
 667   3            key_count = 1;
 668   3            key = (u8)P35<<5;key |= (u8)P42<<6;key |= (u8)P44<<7;
 669   3            P3=0xff;P35=0;P4=0x00;
 670   3            delay12us();
 671   3            key |= P3 &0x0c;
 672   3            switch(key){
 673   4              case 0x64:key_flag=4;break;
 674   4              case 0x68:key_flag=5;break;
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 12  

 675   4              case 0xa4:key_flag=8;break;
 676   4              case 0xa8:key_flag=9;break;
 677   4              case 0xc4:key_flag=12;break;
 678   4              case 0xc8:key_flag=13;break;
 679   4            }
 680   3          }
 681   2          return;
 682   2        }
 683   1        if(key_count>1000){
 684   2          key_count = 0;
 685   2          key_sign = key_flag +10;
 686   2        }else if(key_count>2){
 687   2          key_count=0;
 688   2          key_sign = key_flag;
 689   2        }else{
 690   2          key_count=0;
 691   2        }
 692   1      }
 693          /*************************************************
 694          *函数：dis_smg()数码管显示函数
 695          *功能：驱动显示数码管
 696          *************************************************/
 697          void dis_smg(){
 698   1        u8 i;
 699   1      
 700   1        for(i=0;i<8;i++){
 701   2          P2&=0x1f;
 702   2          P0=1<<i;
 703   2          P2|=y6;
 704   2          _nop_();
 705   2          P2&=0x1f;
 706   2          P0=dis[i];
 707   2          P2|=y7;
 708   2          delay100us();
 709   2          P0=0xff;
 710   2        }
 711   1      }
 712          /*************************************************
 713          *函数：dis_led()LED显示函数
 714          *功能：驱动显示LED
 715          *************************************************/
 716          void dis_led(){
 717   1        P2&=0x1f;
 718   1        P0=~led;
 719   1        P2|=y4;
 720   1        P2&=0x1f;
 721   1      }
 722          /*************************************************
 723          *函数：dis_out()OUT显示函数
 724          *功能：驱动显示OUT
 725          *************************************************/
 726          void dis_out(){
 727   1        P2&=0x1f;
 728   1        P0=out;
 729   1        P2|=y5;
 730   1        P2&=0x1f;
 731   1      }
 732          /*************************************************
 733          *函数：main()系统进入函数
 734          *功能：系统进入初始化服务，系统进行服务
 735          *************************************************/
 736          void main(){
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 13  

 737   1        //初始化
 738   1        init();
 739   1        while(1){
 740   2          //快速I/O操作
 741   2          loop();
 742   2          //中断检查与处理
 743   2          soft_IT();
 744   2        } 
 745   1      }
 746          /*************************************************
 747          *函数：T0_it()T0中断函数
 748          *功能：设置T0计数溢出的情况
 749          *************************************************/
 750          void T0_it() interrupt 1 using 1
 751          {
 752   1        freq_T++;
 753   1        TR0 = 0;
 754   1        TF0 = 0;
 755   1      }
 756          
 757          /*************************************************
 758          *函数：Uart()串口中断处理函数
 759          *功能：软件中断标志的定时置位服务，毫秒级的计时计数服务
 760          *硬件：使用T2定时器，规定1ms溢出中断一次
 761          *************************************************/
 762          void Uart() interrupt 4 using 2
 763          {
 764   1          if (RI){
 765   2            RI = 0;                 //清除RI位
 766   2            rx_buf[rx_pot] = SBUF;//存串口数据
 767   2            if(rx_buf[rx_pot]=='?'){
 768   3              rx_pot = 0;
 769   3            }else if(rx_buf[rx_pot]=='\n'){
 770   3              rx_buf[++rx_pot] ='\0';
 771   3              rx_flag = 1;
 772   3              rx_pot = 0;   
 773   3            }else{
 774   3              if(++rx_pot>=15) rx_pot = 0;
 775   3            }
 776   2          }
 777   1          if (TI){
 778   2            TI = 0;                 //清除TI位
 779   2            if(tx_buf[tx_pot]){
 780   3              SBUF = tx_buf[tx_pot];                 //写数据到UART数据寄存器
 781   3            if(++tx_pot>=15) tx_pot=0;
 782   3          }else{
 783   3            tx_pot = 0;
 784   3            tx_flag = 0;
 785   3          }
 786   2        }
 787   1      }
 788          /*************************************************
 789          *函数：PCA_isr()PCA定时器中断处理函数
 790          *功能：脉冲时长计数服务
 791          *硬件：使用PCA定时器，规定溢出和P11下降沿中断
 792          *输出：count记录从定时器打开到下降沿之前的时长计数
 793          *************************************************/
 794          void PCA_isr() interrupt 7 using 3
 795          { 
 796   1        if (CCF0){
 797   2          CCF0 = 0;
 798   2          length = (CCAP0H<<8)|CCAP0L;  //保存本次的捕获值
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 14  

 799   2          echo_flag = 1;
 800   2          CR = 0;                       //PCA定时器停止工作
 801   2          CCAPM0 &= 0xfe;               //关闭中断
 802   2        }
 803   1        if (CF){
 804   2          CF = 0;
 805   2          break_flag = 1;
 806   2          CR = 0;                       //PCA定时器停止工作
 807   2          CCAPM0 &= 0xfe;               //关闭中断
 808   2        }
 809   1      }
 810          
 811          /*************************************************
 812          *函数：Sysclk_IT()系统定时中断处理函数
 813          *功能：软件中断标志的定时置位服务，毫秒级的计时计数服务
 814          *硬件：使用T2定时器，规定1ms溢出中断一次
 815          *************************************************/
 816          void Sysclk_IT() interrupt 12 using 3
 817          {
 818   1        //毫秒级延时服务
 819   1        if(delay_timing){
 820   2          delay_timing--;
 821   2        }
 822   1        //18B20定时读取
 823   1        if(temp_timing){
 824   2          temp_timing--;
 825   2        }else{
 826   2          temp_timing=500;
 827   2          temp_sign=1;
 828   2        }
 829   1        //超声波定时读取
 830   1        if(len_timing){
 831   2          len_timing--;
 832   2        }else{
 833   2          len_timing=1000;
 834   2          len_flag=1;
 835   2        }
 836   1        //电位器定时读取
 837   1        if(vol_timing){
 838   2          vol_timing--;
 839   2        }else{
 840   2          vol_timing=500;
 841   2          vol_flag=1;
 842   2        }
 843   1        //光敏电阻定时读取
 844   1        if(bright_timing){
 845   2          bright_timing--;
 846   2        }else{
 847   2          bright_timing=500;
 848   2          bright_flag=1;
 849   2        }
 850   1        //EEPROM写时钟
 851   1        if(write_timing){
 852   2          write_timing--;
 853   2        }else{
 854   2          write_timing=1000;
 855   2          if(write_flag){
 856   3            write_sign = write_flag--;
 857   3          }
 858   2        }
 859   1        if(freq_timing){
 860   2          freq_timing--;
C51 COMPILER V9.59.0.0   MAIN                                                              02/01/2020 19:28:08 PAGE 15  

 861   2        }else{
 862   2          freq_timing=5000;
 863   2          count_timing=1000;
 864   2          TH0 = 0x00;
 865   2          TL0 = 0x00;
 866   2          TR0 = 1;
 867   2        }
 868   1        if(count_timing){
 869   2          count_timing--;
 870   2        }else{
 871   2          TR0 = 0;
 872   2          ((u8 *)&freq_sign)[0] = TL0;
 873   2          ((u8 *)&freq_sign)[1] = TH0;
 874   2          freq_H = freq_T;
 875   2          freq_T = 0;
 876   2        }
 877   1        //按键时长计数
 878   1        if(key_count){
 879   2          if(++key_count==0)key_count=1001;
 880   2        }
 881   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5077    ----
   CONSTANT SIZE    =     96    ----
   XDATA SIZE       =     26       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =     69    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
