C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <STC15F2K60S2.H>
   2          #include <intrins.h>
   3          #include <string.h>
   4          #include <stdio.h>
   5          #include <onewire.h>
   6          #include <iic.h>
   7          
   8          #ifndef u8
   9          #define u8 unsigned char
  10          #endif
  11          
  12          #ifndef u16
  13          #define u16 unsigned int
  14          #endif
  15          
  16          #ifndef u32
  17          #define u32 unsigned long
  18          #endif
  19          
  20          sbit Trig = P1^0;
  21          sbit Echo = P1^1;
  22          
  23          u8 code font[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
  24          u8 code y4=0x80,y5=0xa0,y6=0xc0,y7=0xe0;
  25          
  26          bit temp_flag=0,len_flag=0,vol_flag=0,break_flag=0,echo_flag=0,tx_flag=0,rx_flag=0;
  27          bit temp_mod=0;len_mod=1,vol_mod=0;
  28          u8 dis[8]={0},tx_buf[16]="init_well\r\n>>>",rx_buf[16]="\0";
  29          u8 key_flag=0,key_sign=0,tx_pot=0,rx_pot=0;
  30          u16 temp_timing=0,vol_timing=125,len_timing=250;
  31          u16 count=0,len=20,vol=250,key_count=0;
  32          int temp=20;
  33          
  34          void mod_init();
  35          void mod_ctrl();
  36          void read_temp();
  37          void read_len();
  38          void read_vol();
  39          u8 scankey();
  40          void send_str();
  41          void uart_reply();
  42          void dis_smg();
  43          
  44          /*************************************************
  45          *函数：mod_init()系统模式初始化函数
  46          *功能：系统模式初始化
  47          *************************************************/
  48          void mod_init(){
  49   1              if(temp_mod){
  50   2                      dis[0]=0xc6;
  51   2                      dis[1]=0xff;
  52   2                      dis[2]=0xff;
  53   2                      dis[3]=0xff;
  54   2                      return;
  55   2              }else if(len_mod){
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 2   

  56   2                      dis[0]=0xc7;
  57   2                      dis[1]=0xff;
  58   2                      dis[2]=0xff;
  59   2                      return;
  60   2              }else if(vol_mod){
  61   2                      dis[0]=0xc1;
  62   2                      dis[1]=0xff;
  63   2                      dis[2]=0xff;
  64   2                      dis[3]=0xff;
  65   2                      dis[4]=0xff;
  66   2              }
  67   1      }
  68          /*************************************************
  69          *函数：Sysclk_init()系统计时初始化函数
  70          *功能：系统计时初始化
  71          *硬件：使用T2定时器，规定1ms溢出中断一次
  72          *************************************************/
  73          void Sysclk_init(){
  74   1              AUXR |= 0x04;           //定时器2时钟1T模式
  75   1              T2L = 0x20;                     //设置定时初值
  76   1              T2H = 0xD1;                     //设置定时初值
  77   1          IE2 |= 0x04;                //开定时器2中断
  78   1          EA = 1;
  79   1              AUXR |= 0x10;           //定时器2开始计时
  80   1      }
  81          /*************************************************
  82          *函数：PCA_init()PCA定时器初始化函数
  83          *功能：PCA定时器初始化                   
  84          *硬件：使用PCA定时器，规定溢出和P11下降沿中断
  85          *************************************************/
  86          void PCA_init(){
  87   1              P_SW1 &= 0xcf;          //(P1.2/ECI, P1.1/CCP0, P1.0/CCP1, P3.7/CCP2)
  88   1          CCON = 0;                       //初始化PCA控制寄存器
  89   1                                          //PCA定时器停止
  90   1                                          //清除CF标志
  91   1                                          //清除模块中断标志
  92   1          CL = 0;                         //复位PCA寄存器
  93   1          CH = 0;
  94   1          CCAP0L = 0;
  95   1          CCAP0H = 0;
  96   1          CMOD = 0x01;                    //设置PCA时钟源为系统时钟/12,且使能PCA计时溢出中断
  97   1          CCAPM0 = 0x10;                                      //PCA模块0为16位捕获模式(下降沿捕获,可测从低电平开始的整个周期)
  98   1              
  99   1          EA = 1;
 100   1      
 101   1      }
 102          /*************************************************
 103          *函数：Uart_init()串口初始化函数
 104          *功能：串口初始化 
 105          *硬件：使用T1定时器，波特率为4800
 106          *************************************************/
 107          void Uart_init(void)            //4800bps@12.000MHz
 108          {
 109   1              SCON = 0x50;            //8位数据,可变波特率
 110   1              AUXR |= 0x40;           //定时器1时钟为Fosc,即1T
 111   1              AUXR &= 0xFE;           //串口1选择定时器1为波特率发生器
 112   1              TMOD &= 0x0F;           //设定定时器1为16位自动重装方式
 113   1              TL1 = 0x8F;                     //设定定时初值
 114   1              TH1 = 0xFD;                     //设定定时初值
 115   1              ET1 = 0;                        //禁止定时器1中断
 116   1              ES = 1;
 117   1              EA = 1;
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 3   

 118   1              TR1 = 1;                        //启动定时器1
 119   1      
 120   1              send_str();
 121   1      }
 122          /*************************************************
 123          *函数：delay_us()微秒级延时函数
 124          *功能：微秒级延时服务
 125          *备注：尽可能的使用STC-ISP的延时计算器，提高延时精度
 126          *************************************************/
 127          void delay100us()               //@12.000MHz
 128          {
 129   1              unsigned char i, j;
 130   1      
 131   1              i = 2;
 132   1              j = 39;
 133   1              do
 134   1              {
 135   2                      while (--j);
 136   2              } while (--i);
 137   1      }
 138          void delay12us()                //@12.000MHz
 139          {
 140   1              unsigned char i;
 141   1      
 142   1              _nop_();
 143   1              _nop_();
 144   1              i = 33;
 145   1              while (--i);
 146   1      }
 147          /*************************************************
 148          *函数：init()初始化函数
 149          *功能：系统进入的初始化服务
 150          *************************************************/
 151          void init(){
 152   1              mod_init();
 153   1              Trig = 0;
 154   1              Echo = 1;
 155   1              PCA_init();
 156   1              Sysclk_init();
 157   1              Uart_init();
 158   1      }
 159          /*************************************************
 160          *函数：loop()快速响应函数
 161          *功能：快速I/O设备的驱动服务，模式变换服务
 162          *备注：要求函数进行一次的时长要尽可能的短，这样不会影响其他函数的延时等待函数。
 163          *************************************************/
 164          void loop(){
 165   1              key_sign=scankey();
 166   1              mod_ctrl();
 167   1              dis_smg();
 168   1      }
 169          /*************************************************
 170          *函数：soft_IT()中断捕获和处理函数
 171          *功能：中断捕获和处理服务
 172          *************************************************/
 173          void soft_IT(){
 174   1              
 175   1              if(temp_flag) read_temp();
 176   1              if(vol_flag) read_vol();
 177   1              if(len_flag) read_len();
 178   1              if(rx_flag) uart_reply();
 179   1      }
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 4   

 180          /*************************************************
 181          *函数：mod_ctrl()模式变换函数
 182          *功能：模式变换服务
 183          *************************************************/
 184          void mod_ctrl(){
 185   1              u8 i;
 186   1      
 187   1              if(key_sign==4){
 188   2                      temp_mod=0;
 189   2                      vol_mod=0;
 190   2                      len_mod=1;
 191   2                      dis[0]=0xc7;
 192   2                      dis[1]=0xff;
 193   2                      dis[2]=0xff;
 194   2                      if(count==0){
 195   3                              dis[3]=font[9];
 196   3                              dis[4]=font[9];
 197   3                              dis[5]=font[9];
 198   3                              dis[6]=font[9]&0x7f;
 199   3                              dis[7]=font[9];
 200   3                      }else{
 201   3                              len=count*0.17;
 202   3                              dis[3]=font[len/10000];
 203   3                              dis[4]=font[len/1000%10];
 204   3                              dis[5]=font[len/100%10];
 205   3                              dis[6]=font[len/10%10]&0x7f;
 206   3                              dis[7]=font[len%10];
 207   3                              for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 208   3                      }
 209   2                      return;
 210   2              }
 211   1              if(key_sign==5){           
 212   2                      len_mod=0;
 213   2                      vol_mod=0;
 214   2                      temp_mod=1;
 215   2                      dis[0]=0xc6;
 216   2                      dis[1]=0xff;
 217   2                      dis[2]=0xff;
 218   2                      dis[3]=0xff;
 219   2                      dis[4]=font[temp/1000%10];
 220   2                      dis[5]=font[temp/100%10]&0x7f;
 221   2                      dis[6]=font[temp/10%10];
 222   2                      dis[7]=font[temp%10];
 223   2                      for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 224   2                      if(temp<0) dis[i-2]=0xbf;
 225   2                      return;
 226   2              }
 227   1              if(key_sign==8){
 228   2                      len_mod=0;
 229   2                      temp_mod=0;
 230   2                      vol_mod=1;
 231   2                      dis[0]=0xc1;
 232   2                      dis[1]=0xff;
 233   2                      dis[2]=0xff;
 234   2                      dis[3]=0xff;
 235   2                      dis[4]=0xff;
 236   2                      dis[5]=font[vol/100%10]&0x7f;
 237   2                      dis[6]=font[vol/10%10];
 238   2                      dis[7]=font[vol%10];
 239   2              }
 240   1      }
 241          /*************************************************
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 5   

 242          *函数：read_temp()读温度函数
 243          *功能：读取温度
 244          *************************************************/
 245          void read_temp(){
 246   1              int tp;
 247   1              u8 tl,th;
 248   1      
 249   1              while(init_ds18b20())loop();
 250   1              Write_DS18B20(0xCC);
 251   1              Write_DS18B20(0x44);
 252   1              while(init_ds18b20())loop();
 253   1              Write_DS18B20(0xCC);
 254   1              Write_DS18B20(0xBE);
 255   1              tl=Read_DS18B20();
 256   1              th=Read_DS18B20();
 257   1              tp=(th<<8)|tl;
 258   1              temp=tp*6.25;
 259   1      
 260   1              if(temp_mod){
 261   2                      dis[4]=font[temp/1000%10];
 262   2                      dis[5]=font[temp/100%10]&0x7f;
 263   2                      dis[6]=font[temp/10%10];
 264   2                      dis[7]=font[temp%10];
 265   2              }
 266   1              temp_flag=0;
 267   1      
 268   1      }       
 269          /*************************************************
 270          *函数：read_len()读距离函数
 271          *功能：读取距离
 272          *************************************************/
 273          void read_len(){
 274   1              u8 i=8;
 275   1                                
 276   1              //发送
 277   1              while(i--){
 278   2                      Trig = 1;
 279   2                      delay12us();
 280   2                      Trig = 0;
 281   2                      delay12us();
 282   2              }
 283   1              //接收
 284   1          CR = 1;                         //PCA定时器开始工作
 285   1          CCF0 = 0;
 286   1              CCAPM0 |= 0x01;                                 //开启中断
 287   1              while(echo_flag!=0&&break_flag!=0)loop();
 288   1              if(len_mod){
 289   2                      if(break_flag){
 290   3                              dis[3]=font[9];
 291   3                              dis[4]=font[9];
 292   3                              dis[5]=font[9];
 293   3                              dis[6]=font[9]&0x7f;
 294   3                              dis[7]=font[9];
 295   3                      }else{
 296   3                              len=count*0.17;
 297   3                              dis[3]=font[len/10000];
 298   3                              dis[4]=font[len/1000%10];
 299   3                              dis[5]=font[len/100%10];
 300   3                              dis[6]=font[len/10%10]&0x7f;
 301   3                              dis[7]=font[len%10];
 302   3                              for(i=3;dis[i]==font[0];i++) dis[i]=0xff;
 303   3                      }
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 6   

 304   2              }else{
 305   2                      len=count*0.17;
 306   2              }
 307   1              break_flag = 0;
 308   1              echo_flag = 0;
 309   1              len_flag = 0;
 310   1      }
 311          /*************************************************
 312          *函数：read_vol()读电位器函数
 313          *功能：读取电位器电压
 314          *************************************************/
 315          void read_vol(){
 316   1              IIC_Start();
 317   1              IIC_SendByte(0x90);
 318   1              IIC_WaitAck();
 319   1              IIC_SendByte(0x03);
 320   1              IIC_WaitAck();
 321   1              IIC_Start();
 322   1              IIC_SendByte(0x91);
 323   1              IIC_WaitAck();
 324   1              vol=IIC_RecByte();
 325   1              vol=vol*500.0/255;
 326   1              IIC_Stop();
 327   1      
 328   1              if(vol_mod){
 329   2                      dis[5]=font[vol/100%10]&0x7f;
 330   2                      dis[6]=font[vol/10%10];
 331   2                      dis[7]=font[vol%10];
 332   2              }
 333   1      } 
 334          /*************************************************
 335          *函数：send_str()发送字符串函数
 336          *功能：向串口发送字符串
 337          *************************************************/
 338          void send_str(){
 339   1              tx_flag = 1;
 340   1              tx_pot = 0;
 341   1          SBUF = tx_buf[tx_pot++];            //写数据到UART数据寄存器
 342   1      } 
 343          /*************************************************
 344          *函数：uart_reply()串口响应函数
 345          *功能：串口响应接收字符串
 346          *************************************************/
 347          void uart_reply(){
 348   1                      rx_flag = 0;
 349   1                      if(strcmp(rx_buf,"temp\r\n")==0){
 350   2                              while(tx_flag) loop();
 351   2                              sprintf(tx_buf,"temp:%.2f'C\r\n",temp/100.0);
 352   2                              send_str();
 353   2                      }else if(strcmp(rx_buf,"len\r\n")==0){
 354   2                              while(tx_flag) loop();
 355   2                              sprintf(tx_buf,"len:%.1fcm\r\n",len/10.0);
 356   2                              send_str();
 357   2                      }else if(strcmp(rx_buf,"vol\r\n")==0){
 358   2                              while(tx_flag) loop();
 359   2                              sprintf(tx_buf,"vol:%.2fV\r\n",vol/100.0);
 360   2                              send_str();
 361   2                      }
 362   1      }
 363          /*************************************************
 364          *函数：scankey()扫描按键函数
 365          *功能：扫描按键
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 7   

 366          *************************************************/
 367          u8 scankey(){
 368   1              u8 key;
 369   1      
 370   1              P4=0xff;P3=0xff;P3&=0xf3;
 371   1              if(P34==0|P35==0|P42==0|P44==0){
 372   2                      delay100us();
 373   2                      if(P34==0|P35==0|P42==0|P44==0){
 374   3                              if(key_count==0){
 375   4                                      key_count = 1;
 376   4                                      key = P3 &0x30;key|=(u8)P42<<6;key|=(u8)P44<<7;
 377   4                                      P3=0xff;P3&=0xcf;P4=0x00;
 378   4                                      delay12us();
 379   4                                      key |= P3 &0x0c;
 380   4                                      switch(key){
 381   5                                              case 0x74:key_flag=4;break;
 382   5                                              case 0x78:key_flag=5;break;
 383   5                                              case 0xb4:key_flag=8;break;
 384   5                                              case 0xb8:key_flag=9;break;
 385   5                                              case 0xd4:key_flag=12;break;
 386   5                                              case 0xd8:key_flag=13;break;
 387   5                                              case 0xe4:key_flag=16;break;
 388   5                                              case 0xe8:key_flag=17;break;
 389   5                                      }
 390   4                              }
 391   3                              return 0;
 392   3                      }       
 393   2              }
 394   1              if(key_count){
 395   2                      if(key_count<1000){
 396   3                              key_count=0;
 397   3                              return key_flag;
 398   3                      }else{
 399   3                              key_count=0;
 400   3                              return key_flag+10;
 401   3                      }
 402   2              }
 403   1              return 0;
 404   1      }
 405          /*************************************************
 406          *函数：dis_smg()数码管显示函数
 407          *功能：驱动显示数码管
 408          *************************************************/
 409          void dis_smg(){
 410   1              u8 i;
 411   1      
 412   1              for(i=0;i<8;i++){
 413   2                      P2&=0x1f;
 414   2                      P0=1<<i;
 415   2                      P2|=y6;
 416   2                      _nop_();
 417   2                      P2&=0x1f;
 418   2                      P0=dis[i];
 419   2                      P2|=y7;
 420   2                      delay100us();
 421   2                      P0=0xff;
 422   2              }
 423   1      }
 424          /*************************************************
 425          *函数：main()系统进入函数
 426          *功能：系统进入初始化服务，系统进行服务
 427          *************************************************/
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 8   

 428          void main(){
 429   1              //初始化
 430   1              init();
 431   1              while(1){
 432   2                      //快速I/O操作
 433   2                      loop();
 434   2                      //中断检查与处理
 435   2                      soft_IT();
 436   2              }       
 437   1      }
 438          /*************************************************
 439          *函数：Uart()串口中断处理函数
 440          *功能：软件中断标志的定时置位服务，毫秒级的计时计数服务
 441          *硬件：使用T2定时器，规定1ms溢出中断一次
 442          *************************************************/
 443          void Uart() interrupt 4 using 2
 444          {
 445   1          if (RI){
 446   2              RI = 0;                 //清除RI位
 447   2              rx_buf[rx_pot] = SBUF;//存串口数据
 448   2                      if(rx_buf[rx_pot]=='?'){
 449   3                              rx_pot = 0;
 450   3                      }else if(rx_buf[rx_pot]=='\n'){
 451   3                              rx_buf[++rx_pot] ='\0';
 452   3                              rx_flag = 1;
 453   3                              rx_pot = 0; 
 454   3                              
 455   3                      }else{
 456   3                              if(++rx_pot>=15) rx_pot = 0;
 457   3                      }
 458   2          }
 459   1          if (TI){
 460   2              TI = 0;                 //清除TI位
 461   2              if(tx_buf[tx_pot]){
 462   3                      SBUF = tx_buf[tx_pot];                 //写数据到UART数据寄存器
 463   3                              if(++tx_pot>=15) tx_pot=0;
 464   3                      }else{
 465   3                              tx_pot = 0;
 466   3                              tx_flag = 0;
 467   3                      }
 468   2          }
 469   1      }
 470          /*************************************************
 471          *函数：PCA_isr()PCA定时器中断处理函数
 472          *功能：脉冲时长计数服务
 473          *硬件：使用PCA定时器，规定溢出和P11下降沿中断
 474          *输出：count记录从定时器打开到下降沿之前的时长计数
 475          *************************************************/
 476          void PCA_isr() interrupt 7 using 3
 477          {       
 478   1          if (CF)
 479   1          {
 480   2              CF = 0;                                         //定时器溢出中断
 481   2              break_flag=1;
 482   2          }
 483   1          if (CCF0)
 484   1          {
 485   2                      CCF0 = 0;
 486   2                      echo_flag = 1;
 487   2                      count=(CCAP0H<<8)|CCAP0L;       //保存本次的捕获值
 488   2                      CCAPM0 &= 0xfe;                         //关闭中断
 489   2              CR = 0;                                         //PCA定时器停止工作
C51 COMPILER V9.00   MAIN                                                                  11/21/2019 16:53:14 PAGE 9   

 490   2                      CL = 0;                     //复位PCA寄存器
 491   2                      CH = 0;
 492   2                      CCAP0L = 0;
 493   2                      CCAP0H = 0;
 494   2                      
 495   2          }
 496   1      }
 497          /*************************************************
 498          *函数：Sysclk_IT()系统定时中断处理函数
 499          *功能：软件中断标志的定时置位服务，毫秒级的计时计数服务
 500          *硬件：使用T2定时器，规定1ms溢出中断一次
 501          *************************************************/
 502          void Sysclk_IT() interrupt 12 using 3
 503          {
 504   1              //18B20定时读取
 505   1              if(temp_timing){
 506   2                      temp_timing--;
 507   2              }else{
 508   2                      temp_timing=500;
 509   2                      temp_flag=1;
 510   2              }
 511   1              //超声波定时读取
 512   1              if(len_timing){
 513   2                      len_timing--;
 514   2              }else{
 515   2                      len_timing=1000;
 516   2                      len_flag=1;
 517   2              }
 518   1              //电位器定时读取
 519   1              if(vol_timing){
 520   2                      vol_timing--;
 521   2              }else{
 522   2                      vol_timing=500;
 523   2                      vol_flag=1;
 524   2              }
 525   1              //按键时长计数
 526   1              if(key_count){
 527   2                      if(++key_count==0)key_count=1000;
 528   2              }
 529   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2232    ----
   CONSTANT SIZE    =     72    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     64       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
